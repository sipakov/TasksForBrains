Есть библиотечный класс, занимающийся сборкой шарповых проектов. В тестовых целях предположим, что он выглядит так: 
public class Compiler 
{ 
public byte[] BuildProject( string projectPath ) 
{ 
// Имитируем бурную деятельность. 
Thread.Sleep( 500 ); 

// В реальности здесь будут байты собранной dll-ки. 
return Encoding.UTF8.GetBytes( FilePath ); 
} 
} 
Задача: написать асинхронную обёртку над Compiler-ом, которая будет с его помощью реализовывать фоновую сборку проектов. Этот класс должен удовлетворять следующим требованиям: 
- Необходимо возвращать управление вызывающему коду, не дожидаясь полной сборки проекта. 
- После того как проект будет собран, вызывающий код должен иметь возможность получить байты с результатом. 
- В то время, когда один проект уже обрабатывается, наш класс могут попросить собрать ещё что-нибудь. При этом одновременно можно собирать не более одного проекта - новые задачи должны выполниться, когда компилятор освободится. 
- Реализация должна быть потокобезопасной. 

Дополнительные замечания: 
- Класс Compiler считается библиотечным, и модифицировать его нельзя. 
- Помимо класса с непосредственным решением задачи нужно предоставить тестовый проект, иллюстрирующий его работу. 
- Настоятельно рекомендуется использовать современные возможности фреймворка, а не писать код под .NET 2.0 =)